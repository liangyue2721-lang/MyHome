# 任务执行流程图

## 1. 整体流程

```mermaid
flowchart TD
    A[Quartz触发任务] --> B[任务预处理]
    B --> C{是否需要主节点执行?}
    C -->|是| D{当前是否为主节点?}
    C -->|否| E[获取分布式锁]
    D -->|否| F[记录跳过执行原因]
    D -->|是| E
    E --> G{获取锁成功?}
    G -->|否| H[记录锁获取失败]
    G -->|是| I[检查任务是否应在本地执行]
    I --> J{应在本地执行?}
    J -->|是| K[执行任务]
    J -->|否| L[转发任务到其他节点]
    K --> M[记录执行结果]
    L --> M
    F --> M
    H --> M
    M --> N[释放锁和资源]
    N --> O{执行成功?}
    O -->|是| P[结束]
    O -->|否| Q[告警通知]
    Q --> P
```

## 2. 任务分发决策流程

```mermaid
flowchart TD
    A[TaskDistributor.shouldExecuteLocally] --> B[尝试获取任务锁]
    B --> C{获取任务锁成功?}
    C -->|否| D[任务已在其他节点执行\n返回false]
    C -->|是| E[判断当前节点类型]
    E --> F{当前节点是主节点?}
    F -->|是| G[获取当前节点负载]
    F -->|否| H[从节点处理流程]
    G --> I{负载 >= 阈值?}
    I -->|是| J[获取最低负载节点]
    I -->|否| K[在主节点执行\n返回true]
    J --> L{找到可用节点?}
    L -->|是| M[通过Redis消息队列发送任务]
    L -->|否| N[在主节点执行\n返回true]
    M --> O[返回false]
    N --> P[在主节点执行\n返回true]

    H --> Q[尝试从本地队列获取任务]
    Q --> R{本地队列有任务?}
    R -->|是| S[在本地执行\n返回true]
    R -->|否| T[未获取到任务\n返回false]
```

## 3. 从节点任务获取流程

```mermaid
flowchart TD
    A[tryAcquireTaskFromQueue] --> B[随机延迟避免争抢]
    B --> C[检查本地队列是否有任务]
    C --> D{队列中有任务?}
    D -->|是| E[尝试从队列获取任务]
    D -->|否| F[获取所有节点列表]
    E --> G{获取到指定任务?}
    G -->|是| H[在本地执行\n返回true]
    G -->|否| I[继续处理]
    F --> J{有其他节点?}
    J -->|是| K[随机选择一个节点]
    J -->|否| L[返回false]
    K --> M[将任务放入选中节点队列]
    M --> N[记录转发日志]
    N --> O[返回false]
    I --> F
    L --> O
    H --> O
```

## 4. Redis消息队列处理流程

```mermaid
flowchart TD
    A[RedisMessageQueue] --> B[发送任务消息]
    B --> C[构造TaskMessage对象]
    C --> D[序列化为JSON]
    D --> E[推送到目标节点队列]
    E --> F[记录发送日志]

    G[消息监听] --> H[启动监听线程]
    H --> I[阻塞式获取消息]
    I --> J{获取到消息?}
    J -->|是| K[解析消息]
    J -->|否| L[继续监听]
    K --> M[处理任务消息]
    M --> N[记录处理日志]
    N --> L
    L --> I
```

## 5. 详细说明

### 5.1 主节点任务处理流程

1. **任务触发**: Quartz根据调度配置触发任务执行
2. **主节点检查**: 
   - 检查任务是否需要在主节点执行
   - 如果需要但当前不是主节点，则跳过执行
3. **获取分布式锁**: 
   - 使用Redis分布式锁确保任务不会在多个节点同时执行
   - 锁的key为`quartz:lock:` + jobKey
4. **任务分发决策**: 
   - 检查主节点当前负载情况
   - 如果负载超过阈值(默认80%)，选择负载最低的节点执行任务
   - 通过Redis消息队列发送任务给目标节点
5. **任务执行**: 
   - 如果任务应在当前节点执行，则调用具体业务逻辑
   - 通过JobInvokeUtil.invokeMethod()调用配置的业务方法
6. **资源清理**: 
   - 释放分布式锁
   - 清理任务锁
   - 记录任务执行日志

### 5.2 从节点任务处理流程

1. **任务监听**: 
   - 从节点监听自己的Redis任务队列
   - 定期检查队列中是否有待处理任务
2. **任务获取**: 
   - 从队列中获取任务消息
   - 解析任务信息
3. **任务执行**: 
   - 执行具体的业务逻辑
   - 记录执行日志
4. **主动获取**: 
   - 从节点也可以主动尝试获取任务
   - 如果本地队列没有任务，可以转发给其他节点

### 5.3 负载均衡机制

1. **负载检测**: 
   - 定期上报各节点线程池使用率
   - 使用率 = 活跃线程数 / 最大线程数
2. **负载判断**: 
   - 主节点负载阈值默认为0.8(80%)
   - 超过阈值时触发任务分发
3. **节点选择**: 
   - 选择线程池使用率最低的节点执行任务
   - 确保整个集群的负载均衡

### 5.4 防止重复执行机制

1. **Quartz分布式锁**: 
   - 确保同一任务在集群环境中不会被多个节点同时调度
2. **任务执行锁**: 
   - 确保同一任务不会在多个节点同时执行
3. **@DisallowConcurrentExecution注解**: 
   - 确保特定任务不会并发执行
4. **消息队列隔离**: 
   - 每个节点只处理自己的队列中的任务

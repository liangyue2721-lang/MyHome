# 算法 300 题刷题手册（中文思路 + Java 完整解法）

## 数组 & 双指针

### 数组 & 双指针 经典题目 1（LeetCode 1）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 2（LeetCode 2）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 3（LeetCode 3）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 4（LeetCode 4）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 5（LeetCode 5）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 6（LeetCode 6）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 7（LeetCode 7）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 8（LeetCode 8）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 9（LeetCode 9）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 10（LeetCode 10）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 11（LeetCode 11）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 12（LeetCode 12）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 13（LeetCode 13）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 14（LeetCode 14）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 15（LeetCode 15）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 16（LeetCode 16）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 17（LeetCode 17）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 18（LeetCode 18）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 19（LeetCode 19）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 20（LeetCode 20）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 21（LeetCode 21）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 22（LeetCode 22）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 23（LeetCode 23）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 24（LeetCode 24）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 25（LeetCode 25）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 26（LeetCode 26）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 27（LeetCode 27）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 28（LeetCode 28）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 29（LeetCode 29）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 30（LeetCode 30）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 31（LeetCode 31）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 32（LeetCode 32）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 33（LeetCode 33）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 34（LeetCode 34）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 35（LeetCode 35）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 36（LeetCode 36）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 37（LeetCode 37）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 38（LeetCode 38）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 39（LeetCode 39）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 数组 & 双指针 经典题目 40（LeetCode 40）

**思路（中文）**：哈希表/双指针/排序综合技巧

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

## 字符串

### 字符串 经典题目 1（LeetCode 41）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 2（LeetCode 42）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 3（LeetCode 43）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 4（LeetCode 44）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 5（LeetCode 45）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 6（LeetCode 46）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 7（LeetCode 47）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 8（LeetCode 48）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 9（LeetCode 49）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 10（LeetCode 50）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 11（LeetCode 51）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 12（LeetCode 52）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 13（LeetCode 53）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 14（LeetCode 54）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 15（LeetCode 55）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 16（LeetCode 56）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 17（LeetCode 57）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 18（LeetCode 58）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 19（LeetCode 59）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 20（LeetCode 60）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 21（LeetCode 61）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 22（LeetCode 62）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 23（LeetCode 63）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 24（LeetCode 64）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 25（LeetCode 65）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 26（LeetCode 66）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 27（LeetCode 67）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 28（LeetCode 68）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 29（LeetCode 69）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 30（LeetCode 70）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 31（LeetCode 71）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 32（LeetCode 72）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 33（LeetCode 73）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 34（LeetCode 74）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 35（LeetCode 75）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 36（LeetCode 76）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 37（LeetCode 77）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 38（LeetCode 78）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 39（LeetCode 79）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

### 字符串 经典题目 40（LeetCode 80）

**思路（中文）**：滑动窗口与哈希统计

``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l=0,ans=0;
        for(int r=0;r<s.length();r++){
            while(set.contains(s.charAt(r))){
                set.remove(s.charAt(l++));
            }
            set.add(s.charAt(r));
            ans=Math.max(ans,r-l+1);
        }
        return ans;
    }
}
```

## 链表

### 链表 经典题目 1（LeetCode 81）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 2（LeetCode 82）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 3（LeetCode 83）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 4（LeetCode 84）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 5（LeetCode 85）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 6（LeetCode 86）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 7（LeetCode 87）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 8（LeetCode 88）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 9（LeetCode 89）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 10（LeetCode 90）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 11（LeetCode 91）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 12（LeetCode 92）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 13（LeetCode 93）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 14（LeetCode 94）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 15（LeetCode 95）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 16（LeetCode 96）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 17（LeetCode 97）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 18（LeetCode 98）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 19（LeetCode 99）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 20（LeetCode 100）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 21（LeetCode 101）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 22（LeetCode 102）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 23（LeetCode 103）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 24（LeetCode 104）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 25（LeetCode 105）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 26（LeetCode 106）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 27（LeetCode 107）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 28（LeetCode 108）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 29（LeetCode 109）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

### 链表 经典题目 30（LeetCode 110）

**思路（中文）**：链表指针操作与快慢指针

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre=null;
        while(head!=null){
            ListNode nxt=head.next;
            head.next=pre;
            pre=head;
            head=nxt;
        }
        return pre;
    }
}
```

## 树

### 树 经典题目 1（LeetCode 111）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 2（LeetCode 112）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 3（LeetCode 113）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 4（LeetCode 114）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 5（LeetCode 115）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 6（LeetCode 116）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 7（LeetCode 117）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 8（LeetCode 118）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 9（LeetCode 119）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 10（LeetCode 120）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 11（LeetCode 121）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 12（LeetCode 122）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 13（LeetCode 123）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 14（LeetCode 124）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 15（LeetCode 125）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 16（LeetCode 126）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 17（LeetCode 127）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 18（LeetCode 128）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 19（LeetCode 129）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 20（LeetCode 130）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 21（LeetCode 131）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 22（LeetCode 132）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 23（LeetCode 133）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 24（LeetCode 134）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 25（LeetCode 135）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 26（LeetCode 136）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 27（LeetCode 137）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 28（LeetCode 138）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 29（LeetCode 139）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 30（LeetCode 140）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 31（LeetCode 141）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 32（LeetCode 142）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 33（LeetCode 143）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 34（LeetCode 144）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 35（LeetCode 145）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 36（LeetCode 146）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 37（LeetCode 147）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 38（LeetCode 148）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 39（LeetCode 149）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

### 树 经典题目 40（LeetCode 150）

**思路（中文）**：DFS递归/层序遍历

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

## 动态规划 DP

### 动态规划 DP 经典题目 1（LeetCode 151）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 2（LeetCode 152）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 3（LeetCode 153）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 4（LeetCode 154）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 5（LeetCode 155）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 6（LeetCode 156）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 7（LeetCode 157）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 8（LeetCode 158）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 9（LeetCode 159）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 10（LeetCode 160）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 11（LeetCode 161）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 12（LeetCode 162）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 13（LeetCode 163）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 14（LeetCode 164）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 15（LeetCode 165）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 16（LeetCode 166）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 17（LeetCode 167）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 18（LeetCode 168）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 19（LeetCode 169）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 20（LeetCode 170）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 21（LeetCode 171）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 22（LeetCode 172）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 23（LeetCode 173）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 24（LeetCode 174）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 25（LeetCode 175）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 26（LeetCode 176）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 27（LeetCode 177）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 28（LeetCode 178）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 29（LeetCode 179）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 30（LeetCode 180）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 31（LeetCode 181）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 32（LeetCode 182）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 33（LeetCode 183）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 34（LeetCode 184）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 35（LeetCode 185）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 36（LeetCode 186）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 37（LeetCode 187）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 38（LeetCode 188）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 39（LeetCode 189）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

### 动态规划 DP 经典题目 40（LeetCode 190）

**思路（中文）**：状态转移方程与滚动数组

``` java
class Solution {
    public int climbStairs(int n) {
        int a=1,b=1;
        for(int i=2;i<=n;i++){
            int c=a+b;
            a=b;b=c;
        }
        return b;
    }
}
```

## 图论

### 图论 经典题目 1（LeetCode 191）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 2（LeetCode 192）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 3（LeetCode 193）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 4（LeetCode 194）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 5（LeetCode 195）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 6（LeetCode 196）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 7（LeetCode 197）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 8（LeetCode 198）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 9（LeetCode 199）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 10（LeetCode 200）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 11（LeetCode 201）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 12（LeetCode 202）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 13（LeetCode 203）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 14（LeetCode 204）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 15（LeetCode 205）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 16（LeetCode 206）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 17（LeetCode 207）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 18（LeetCode 208）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 19（LeetCode 209）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 20（LeetCode 210）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 21（LeetCode 211）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 22（LeetCode 212）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 23（LeetCode 213）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 24（LeetCode 214）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 25（LeetCode 215）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 26（LeetCode 216）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 27（LeetCode 217）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 28（LeetCode 218）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 29（LeetCode 219）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

### 图论 经典题目 30（LeetCode 220）

**思路（中文）**：DFS/BFS遍历图与连通分量

``` java
class Solution {
    public int numIslands(char[][] grid) {
        int m=grid.length,n=grid[0].length,cnt=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    cnt++;
                }
            }
        }
        return cnt;
    }
    void dfs(char[][] g,int i,int j){
        if(i<0||j<0||i==g.length||j==g[0].length||g[i][j]=='0') return;
        g[i][j]='0';
        dfs(g,i+1,j);dfs(g,i-1,j);dfs(g,i,j+1);dfs(g,i,j-1);
    }
}
```

## 栈队列堆

### 栈队列堆 经典题目 1（LeetCode 221）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 2（LeetCode 222）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 3（LeetCode 223）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 4（LeetCode 224）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 5（LeetCode 225）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 6（LeetCode 226）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 7（LeetCode 227）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 8（LeetCode 228）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 9（LeetCode 229）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 10（LeetCode 230）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 11（LeetCode 231）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 12（LeetCode 232）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 13（LeetCode 233）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 14（LeetCode 234）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 15（LeetCode 235）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 16（LeetCode 236）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 17（LeetCode 237）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 18（LeetCode 238）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 19（LeetCode 239）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 20（LeetCode 240）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 21（LeetCode 241）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 22（LeetCode 242）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 23（LeetCode 243）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 24（LeetCode 244）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 25（LeetCode 245）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 26（LeetCode 246）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 27（LeetCode 247）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 28（LeetCode 248）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 29（LeetCode 249）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 栈队列堆 经典题目 30（LeetCode 250）

**思路（中文）**：栈与优先队列的典型应用

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

## 设计题

### 设计题 经典题目 1（LeetCode 251）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 2（LeetCode 252）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 3（LeetCode 253）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 4（LeetCode 254）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 5（LeetCode 255）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 6（LeetCode 256）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 7（LeetCode 257）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 8（LeetCode 258）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 9（LeetCode 259）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 10（LeetCode 260）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 11（LeetCode 261）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 12（LeetCode 262）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 13（LeetCode 263）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 14（LeetCode 264）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 15（LeetCode 265）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 16（LeetCode 266）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 17（LeetCode 267）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 18（LeetCode 268）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 19（LeetCode 269）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

### 设计题 经典题目 20（LeetCode 270）

**思路（中文）**：数据结构设计与哈希思想

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int d = target - nums[i];
            if(map.containsKey(d)) return new int[]{map.get(d), i};
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

## 高难度

### 高难度 经典题目 1（LeetCode 271）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 2（LeetCode 272）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 3（LeetCode 273）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 4（LeetCode 274）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 5（LeetCode 275）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 6（LeetCode 276）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 7（LeetCode 277）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 8（LeetCode 278）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 9（LeetCode 279）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 10（LeetCode 280）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 11（LeetCode 281）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 12（LeetCode 282）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 13（LeetCode 283）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 14（LeetCode 284）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 15（LeetCode 285）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 16（LeetCode 286）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 17（LeetCode 287）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 18（LeetCode 288）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 19（LeetCode 289）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 20（LeetCode 290）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 21（LeetCode 291）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 22（LeetCode 292）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 23（LeetCode 293）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 24（LeetCode 294）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 25（LeetCode 295）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 26（LeetCode 296）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 27（LeetCode 297）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 28（LeetCode 298）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 29（LeetCode 299）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```

### 高难度 经典题目 30（LeetCode 300）

**思路（中文）**：双指针+剪枝+复杂边界处理

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i=0;i<nums.length-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.length-1;
            while(l<r){
                int s=nums[i]+nums[l]+nums[r];
                if(s==0){
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r && nums[l]==nums[l+1]) l++;
                    while(l<r && nums[r]==nums[r-1]) r--;
                    l++;r--;
                }else if(s<0) l++;
                else r--;
            }
        }
        return res;
    }
}
```
